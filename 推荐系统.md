深度学习在推荐系统中的应用

[TOC]

### 推荐系统的作用

- ==解决信息过载==，用户高效获取感兴趣的问题
- 提高用户转化率，得到商业目标增长

### 推荐系统的架构

#### 逻辑框架

- 对于用户U，在特定场景C下，针对海量物品信息，构建函数f(U,I,C)，预测用户对特定候选物品I的喜好程度
- 根据喜好程度对所有候选物品筛选，排序，生成推荐列表

#### 技术架构

##### 数据部分

- 数据如何获得，存储，更新和处理
- 客户端/服务器端实时数据处理，
  - 流处理平台Flink
  - 大数据平台Spark。
- 区分三类信息，用户信息，物品信息，场景信息
- 特征工程
  - 数值特征的 归一化/离散化/非线性变化，
  - ID（离散）特征的 onehot编码/Embedding
  - 特征组合
- 用户特征：用户行为，社交关系，属性标签
- 物品特征：内容类数据，属性表情，第三方信息
- 场景特征：时间，地点，页面场景

##### 模型部分

- 

在拿到推荐系统的原始数据之后，推荐系统会进一步加工，数据出口有三个

- 生成推荐模型锁需要的样本数据，用于算法模型的训练和评估
- 生成推荐模型服务（model serving）所需的「特征」，用于推荐系统的线上推断
- 生成系统监控、商业智能（Business Intelligence，BI）所需的统计数据

推荐系统「模型部分」是推荐系统的主题，一般由「召回层」「排序」「补充策略与算法层」组成。

- 召回层：利用高效的召回规则、算法或简单模型，快速从海量的候选集召回用户可能感兴趣的物品
- 排序层：利用排序模型对初筛的候选集进行精排序
- 补充策略与算法：也被称为再排序层，在推荐列表返回用户之前，兼顾结果的多样性、流行度、新鲜度等指标，结合一些补充的策略和算法对推荐列表进行一定的调整，最终形成用户可见的推荐里列表。

### 推荐系统的进化(DL之前)

传统推荐模型的发展主要经历了四个阶段：

- **协同过滤 CF 算法阶段** ：只需用户物品共现矩阵就可以构建推荐系统，根据相似度取值对象可分为 itemCF 和 userCF 两类，优势是简单易实现。CF 的问题是泛化能力弱，无法应对稀疏矩阵，而矩阵分解作为协同过滤的进化版，克服了 CF 的缺点。
- **逻辑回归 LR 阶段** ：综合利用用户、物品、上下文等多种不同的特征，假设用户是否点击广告服从伯努利分布，将推荐问题转化为点击率预估 (CTR) 问题，预测正样本概率对物品进行排序。其数学形式是各个特征的加权和经过 sigmoid 函数，得到用户点击物品的概率。LR 的优势是可解释性强、易于并行化、模型简单、训练开销小。其局限性在于表达能力不强，需要大量具有业务背景知识的人工特征筛选与交叉。
- **因子分解机 FM 阶段** ：为每个特征学习一个隐向量，在特征交叉时，使用两个特征隐向量的内积作为交叉特征的权重。虽然 FM 相比 POLY2 的完全交叉 + 单一权重记忆能力略弱，但解决了特征交叉过程中交叉特征对应的数据过于稀疏无法充分学习权重的问题。FFM 引入特征域进一步增强了模型的表达能力，做特征交叉时，每个特征选择与对方域对应的隐向量的内积作为交叉特征的权重，但 FFM 的计算复杂度也由 kn 上升到 kn*n。
- **组合模型阶段** ：这一阶段主要是为了进一步提高特征交叉的维度，同时融合多个模型的优点。GBDT+LR 是组合模型的代表方案，GBDT 自动进行特征筛选和组合得到新的离散特征向量输入 LR 模型。GBDT+LR 的组合方式开启了特征工程模型化的趋势，真正实现端到端训练。

### 深度学习在推荐系统中的应用

两类思路：

- 特征工程自动化的思路：PNN，Wide&Deep，Deep&Cross，FNN，DeepFM，NFM
- 模型结构的尝试：Attention，序列模型，强化学习

深度学习的推荐模型从多层感知机MLP出发，有七个演变方向：

- 改变神经网络的复杂程度

- 丰富特征交叉方式：改变特征变量的交叉方式

- 组合模型

- FM模型的深度学习演化

- 引入Attention机制：包括AFM（Attention Factorization Machine）和DIN（Deep Interest Network）

- 融合序列模型，模拟用户行为和兴趣的演化趋势

- 结合强化学习

  

### Embedding在推荐系统中的应用

embedding用低维稠密的向量表示一个对象（object），向量能表达相应对象的某些特征，向量之间的距离也表示了物品的相似性

Embedding的重要性体现：

- 对one-hot编码的处理需要低维稠密表示
- Embedding本身是重要的特征向量
- 对物品，用户相似度的计算可以用于召回层，为局部敏感哈希等快速最近邻搜索技术应用推荐系统提供了基础

#### 从Word2vec到item2vec

Word2vec是经典的生成词向量的方法，item2vec（2017微软论文）运用负采样，以item出现在同一集合为正例，否则为负例生成embedding。同一集合的一个例子：用户同一订单下的商品。这种方法将embedding扩展到各种可以生成sequence的领域。

KDD2018最佳论文，Airbnb的item2vec：

- Listing Embedding：用户30分钟内连续点击的房源具有相似性，用skip-gram模型学习
- 将最终预定的房源视为强信息，作为全局context
- 对相同market的房源负采样负例

一般来说，由于推荐系统的物品库非常巨大，远超NLP中的词表，因此训练开销也很巨大，embedding层的训练在这里往往独立于主网络。

#### 基于图结构的embedding

- DeepWalk：在图上随机游走，产生物品序列，然后使用Word2vec

#### 局部敏感hash

- 基本思想是让相邻的点落入同一个桶，但既然源空间大于目标空间，距离就无法完全维持，因此这种局部敏感是相对的
- 本质上哈希函数是一个降维函数，数据从信息量大的高维降到低维。

### 特征工程

#### 推荐系统常用的特征

- 用户行为数据

  - 显式反馈：明确的评分，喜欢/不喜欢
  - 隐式反馈：浏览，各种行为时长
  - 前者数量小但含义明确，实时获取。后者数量大但含义不明确，需要分析后使用

- 用户关系数据

- 显性属性，标签数据

- 内容类数据（需要通过NLP，CV等手段转化）

- 上下文信息

  - ###### 描述推荐行为的场景，如时间地点，月份，社会事件，天气等等

  - 最典型的例子是季节和商品的关系，人们夏天吃冰淇淋，冬天吃火锅

  - 给某个用户推荐过的物品某种程度上不应该再推荐，也即时间多样性

- 统计类特征：历史CTR等

- 组合特征

#### 数值特征的处理

- 如果数据的分布符合某种分布，如高斯分布，可以使用损失函数
- 有时太多的精度只是噪声，**截断**使其成为类别特征
- 一些计数特征可以快速累加，可以标示是否存在为二值变量，或者分桶。
- 标准化（缩放）
- 对缺失值补均值或中位数，或者编码一个缺失数
- 统计量，如均值，方差，偏度，峰度，正负值比例。

#### 类别特征的处理





### Parameter Server的分布式训练

- 分布式训练自然包括两个部分，server group和多个worker group
- Parameter Server的主要模式还是异步非阻断的
- 用一致性hash，利用range pull和range push等工程手段实现信息的最小传递



### 增加实时性

- 模型训练最常用的是**全量更新**，即利用某段时间内所有的训练样本进行重新训练，在替代旧的模型，这所需的时间往往较长，在离线的大数据平台上训练
- 增量更新指仅将新加入的样本喂入模型进行增量学习，往往在增加数据不多的情况下效果较好，但几轮之后就需要重新全局更新
- 在线学习指每获得一个新样本就更新模型，模型在设计时也考虑不断获取新数据
- 模型局部更新：降低训练效率低的部分的更新频率，如facebook的GBDT+LR。其中前者较少更新而后者经常更新
- 客户端模型更新：与用户有关的部分数据可以在客户端完成，比如实时更改用户的embedding，完成实时推荐（还在探索阶段）

### 多目标排序





### 冷启动的解决方法

- 主要有三大类：用户冷启动，物品冷启动，系统冷启动
- 冷启动策略：
  - 利用注册信息做粗粒度的个性化
  - 利用其它社交网络的好友做协同过滤
  - 注册时做粗反馈
  - 物品可以利用内容信息和相似的物品
- 冷启动的主要问题在于推荐系统的很多参数更新代价很大，用户行为数据量很大，因此难以频繁更新，但是冷启动就是需要快速迭代更新的。
- 在一个主要依赖推荐系统的网站，这是一个“探索与利用”问题
  - 传统的方法是简化为多臂老虎机问题，利用e-Greedy，Thompson，Sampling，UCB等方法。但是没有办法引入用户的上下文和个性化信息。
  - 个性化方法：如LinUCB
  - 基于模型的方法，如DRN中的探索网络

### 推荐系统的评估

- 线上AB test是昂贵的，影响部分用户体验，只能很小范围使用
- 线下的评估多种多样，但是线上的评估却很困难简单实现，而又不伤害用户体验
- 线下评估
  - holdout检验
  - 交叉验证
  - 自助法
  - Replay：逐一样本回放的精确线上仿真过程
- 采用最近的一次数据作为测试集可以避免引入future information，即用未来的数据预测过去，这不符合问题定义。



### 推荐系统的线上Serving

#### 基本解决方案

- 线上Serving，就是讲训练好的模型部署在线上的生产环境，进行实时的inference
- 前面所说的大量方法聚焦于利用离线数据，设计并训练模型，以及业务本身带来的模型设计（如冷启动，实时性）。但线上的应用还有性能和资源问题需要解决。
- 常见解决方案包括：自研平台，预训练Embedding+轻量级模型
- PMML全称Predictive Model Markup Language，常被用于中间媒介连接离线训练平台和线上预测平台。
- TensorFlow Serving等原生平台。
- Flask或者Django来写服务api，性能较低





http://www.python88.com/topic/62566

https://amylewis.github.io/2020/07/21/Rec_sys_book_reading/index.html